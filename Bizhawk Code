local items = {
	[0x00] = 'Sword of Wind',
	[0x01] = 'Sword of Fire',
	[0x02] = 'Sword of Water',
	[0x03] = 'Sword of Thunder',
	[0x04] = 'Crystalis',
	[0x05] = 'Ball of Wind',
	[0x07] = 'Ball of Fire',
	[0x09] = 'Ball of Water',
	[0x0B] = 'Ball of Thunder',
	[0x06] = 'Tornado Braclet',
	[0x08] = 'Flame Braclet',
	[0x0A] = 'Blizzard Braclet',
	[0x0C] = 'Storm Braclet',

	[0x0A] = 'ArmorXXX',
	[0x0B] = 'ShieldXXX',

	[0x1D] = 'Medical Herb',
	[0x1E] = 'Antidote',
	[0x1F] = 'Lysis Plant',
	[0x21] = 'Fruit of Power',
	[0x20] = 'Fruit of Lime',
	[0x23] = 'Fruit of Repun',
	[0x22] = 'Magic Ring',
--	[0xXX] = 'Opel Statue',
	[0x24] = 'Warp Boots',

	[0x29] = 'Hazmat Suit',
	[0x2B] = 'Warrior Ring',
	[0x2A] = 'Power Ring',
	[0x30] = 'Shield Ring',
	[0x2C] = 'Iron Necklace',
	[0x2D] = 'Deo Pendant',
	[0x2F] = 'Speed Boots',
	[0x2E] = 'Rabbit Boots',

	[0x32] = 'Windmill Key',
	[0x33] = 'Key to the Prison',
	[0x34] = 'Key to Styx',
--	[0xXX] = 'Alarm Flute',
--	[0x21] = 'Insect Flute',
--	[0x22] = 'Flute of Lime',
	[0x36] = 'Shell Flute',
	[0x3E] = 'Bow of Moon',
	[0x3F] = 'Bow of Sun',
	[0x40] = 'Bow of Truth',
	[0x25] = 'Statue of Onyx',
	[0x3D] = 'Ivory Statue',
	[0x38] = 'Broken Statue',
	[0x3A] = 'Golden Statue',
	[0x35] = 'Fog Lamp',
	[0x39] = 'Glowing Lamp',
	[0x3C] = 'Karissa Plant',
	[0x3B] = 'Love Pendant',
	[0x37] = 'Xray Glasses',

	[0x41] = 'Refresh',
	[0x43] = 'Telepathy',
	[0x42] = 'Paralysis',
	[0x44] = 'Teleport',
	[0x45] = 'Recover',
	[0x46] = 'Barrier',
	[0x47] = 'Change',
	[0x48] = 'Flight',

	[0x15] = 'Tanned Hide',
	[0x16] = 'Leather Armor',
	[0x17] = 'Bronze Armor',
	[0x18] = 'Platinum Armor',
	[0x19] = 'Soldier Suit',
	[0x1A] = 'Ceramic Suit',
	[0x1B] = 'Battle Armor',
	[0x1C] = 'Psycho Armor',
	[0x0D] = 'Carapace Shield',
	[0x0E] = 'Bronze Shield',
	[0x0F] = 'Platinum Shield',
	[0x10] = 'Mirrored Shield',
	[0x11] = 'Ceramic Shield',
	[0x12] = 'Sacred Shield',
	[0x13] = 'Battle Shield',
	[0x14] = 'Psycho Shield',
}

		private const ushort ADDR_Money1 = 0x0702;
        private const ushort ADDR_Money2 = 0x0703;
        private const ushort ADDR_EXP = 0x0704;
        private const ushort ADDR_HP = 0x03C1;
        private const ushort ADDR_MPC = 0x0708;
        private const ushort ADDR_MPF = 0x0709;
        private const ushort ADDR_HEALTH_MAX = 0x03C0;
 
        private const ushort ADDR_SCALING = 0x648F;
        private const ushort ADDR_LEVEL = 0x0421;

        private const ushort ADDR_U1HOOK = 0x6220;
        private const ushort ADDR_U2HOOK = 0x6221;
		
		private const ushort ADDR_Condition = 0x0710;
        private const ushort ADDR_Warrior = 0x06C0;
        private const ushort ADDR_ChargeLvl = 0x0719;
        private const ushort ADDR_Speed = 0x0341;
        private const ushort ADDR_Jump = 0x0620;
        private const ushort ADDR_ScreenHit1 = 0x07D6;
        private const ushort ADDR_ScreenHit2 = 0x07D7;
        private const ushort ADDR_Equip_Sword = 0x0711;
        private const ushort ADDR_Stone = 0x05A0;



local locations = {
	[0]=
	{["address"]=0x180159, ["name"]="Turtle Rock - Trinexx",	["type"]="Drop"},
	{["address"]=0x180162, ["name"]="Tower of Hera - Basement Cage",	["type"]="Standing\HeraBasement"},
	{["address"]=0x180152, ["name"]="Tower of Hera - Moldorm",	["type"]="Drop"},
	{["address"]=0x180156, ["name"]="Thieves' Town - Blind",	["type"]="Drop"},
	{["address"]=0x180154, ["name"]="Swamp Palace - Arrghus",	["type"]="Drop"},
	{["address"]=0x180155, ["name"]="Skull Woods - Mothula",	["type"]="Drop"},
	{["address"]=0x180153, ["name"]="Palace of Darkness - Helmasaur King",	["type"]="Drop"},
	{["address"]=0x180158, ["name"]="Misery Mire - Vitreous",	["type"]="Drop"},
	{["address"]=0x289B0, ["name"]="Master Sword Pedestal",	["type"]="Pedestal"},
	{["address"]=0x2DF45, ["name"]="Link's Uncle",	["type"]="Npc"},
	{["address"]=0x2EB18, ["name"]="Bottle Merchant",	["type"]="Npc"},
	{["address"]=0x2F1FC, ["name"]="Sahasrahla",	["type"]="Npc"},
	{["address"]=0x180015, ["name"]="Magic Bat",	["type"]="Npc"},
	{["address"]=0x339CF, ["name"]="Sick Kid",	["type"]="Npc\BugCatchingKid"},
	{["address"]=0x33E7D, ["name"]="Hobo",	["type"]="Npc"},
	{["address"]=0x180017, ["name"]="Bombos Tablet",	["type"]="Drop\Bombos"},
	{["address"]=0xEE1C3, ["name"]="King Zora",	["type"]="Npc\Zora"},
	{["address"]=0x180000, ["name"]="Lost Woods Hideout",	["type"]="Standing"},
	{["address"]=0x180001, ["name"]="Lumberjack Tree",	["type"]="Standing"},
	{["address"]=0x180003, ["name"]="Cave 45",	["type"]="Standing"},
	{["address"]=0x180004, ["name"]="Graveyard Ledge",	["type"]="Standing"},
	{["address"]=0x180005, ["name"]="Checkerboard Cave",	["type"]="Standing"},
	{["address"]=0x180010, ["name"]="Mini Moldorm Cave - NPC",	["type"]="Npc"},
	{["address"]=0x180012, ["name"]="Library",	["type"]="Dash"},
	{["address"]=0x180013, ["name"]="Mushroom",	["type"]="Standing"},
--	{["address"]=0x180014, ["name"]="Potion Shop",	["type"]="Npc\Witch"},
	{["address"]=0x180142, ["name"]="Maze Race",	["type"]="Standing"},
	{["address"]=0x180143, ["name"]="Desert Ledge",	["type"]="Standing"},
	{["address"]=0x180144, ["name"]="Lake Hylia Island",	["type"]="Standing"},
	{["address"]=0x180145, ["name"]="Sunken Treasure",	["type"]="Standing"},
	{["address"]=0x180149, ["name"]="Zora's Ledge",	["type"]="Standing"},
	{["address"]=0x18014A, ["name"]="Flute Spot",	["type"]="Dig\HauntedGrove"},
	{["address"]=0x180157, ["name"]="Ice Palace - Kholdstare",	["type"]="Drop"},
	{["address"]=0x180161, ["name"]="Ganon's Tower - Bob's Torch",	["type"]="Dash"},
--	{["address"]=0x348FF, ["name"]="Waterfall Bottle",	["type"]="Fountain"},
--	{["address"]=0x3493B, ["name"]="Pyramid Bottle",	["type"]="Fountain"},
	{["address"]=0x180150, ["name"]="Eastern Palace - Armos Knights",	["type"]="Drop"},
	{["address"]=0x180160, ["name"]="Desert Palace - Torch",	["type"]="Dash"},
	{["address"]=0x180151, ["name"]="Desert Palace - Lanmolas'",	["type"]="Drop"},
	{["address"]=0xF69FA, ["name"]="Old Man",	["type"]="Npc"},
	{["address"]=0x180002, ["name"]="Spectacle Rock Cave",	["type"]="Standing"},
	{["address"]=0x180016, ["name"]="Ether Tablet",	["type"]="Drop\Ether"},
	{["address"]=0x180140, ["name"]="Spectacle Rock",	["type"]="Standing"},
	{["address"]=0x180141, ["name"]="Floating Island",	["type"]="Standing"},
	{["address"]=0x330C7, ["name"]="Stumpy",	["type"]="Npc"},
	{["address"]=0x180011, ["name"]="Hype Cave - NPC",	["type"]="Npc"},
	{["address"]=0x180148, ["name"]="Digging Game",	["type"]="Dig"},
	{["address"]=0x180006, ["name"]="Hammer Pegs",	["type"]="Standing"},
	{["address"]=0x180146, ["name"]="Bumper Cave",	["type"]="Standing"},
	{["address"]=0x33D68, ["name"]="Purple Chest",	["type"]="Npc"},
	{["address"]=0xEE185, ["name"]="Catfish",	["type"]="Standing"},
	{["address"]=0x180147, ["name"]="Pyramid",	["type"]="Standing"},
	{["address"]=0x180028, ["name"]="Pyramid Fairy - Sword",	["type"]="Trade"},
	{["address"]=0x34914, ["name"]="Pyramid Fairy - Bow",	["type"]="Trade"},
	{["address"]=0x18002A, ["name"]="Blacksmith",	["type"]="Npc"},
	{["address"]=0x3355C, ["name"]="Blacksmith",	["type"]="Npc"},
}

local gameLoadedModes = {
    [0x00]=false,  --Mesen Start
    [0x01]=true,  --In Game
    [0x02]=false,  --SNK White Screen
    [0x03]=false,  --Start Continue Screen
    [0x04]=false,  --Tower Ending

}

local continueHP = {
	[03] = 03,
	[04] = 03,
	[05] = 04,
	[06] = 04,
	[07] = 05,
	[08] = 05,
	[09] = 06,
	[10] = 06,
	[11] = 07,
	[12] = 07,
	[13] = 07,
	[14] = 08,
	[15] = 08,
	[16] = 08,
	[17] = 09,
	[18] = 09,
	[19] = 09,
	[20] = 10,
}


local deathQueue = {}
function tableCount(table)
	local count = 0
    for _, _ in pairs(table) do
        count = count + 1
    end
    return count
end

local prevRAM = nil
local gameMode
local prevGameMode = nil

local gameLoaded
local prevGameLoaded = true
local dying = false
local prevmode = 0
local lttp_ram = {}
local playercount = 1

-- Writes value to RAM using little endian
local prevDomain = ""
function writeRAM(domain, address, size, value)
	-- update domain
	if (prevDomain ~= domain) then
		prevDomain = domain
		if not memory.usememorydomain(domain) then
			return
		end
	end

	-- default size short
	if (size == nil) then
		size = 2
	end

	if (value == nil) then
		return
	end

	if size == 1 then
		memory.writebyte(address, value)
	elseif size == 2 then
		memory.write_u16_le(address, value)
	elseif size == 4 then
		memory.write_u32_le(address, value)
	end
end

-- Reads a value from RAM using little endian
function readRAM(domain, address, size)
	-- update domain
	if (prevDomain ~= domain) then
		prevDomain = domain
		if not memory.usememorydomain(domain) then
			return
		end
	end

	-- default size short
	if (size == nil) then
		size = 2
	end

	if size == 1 then
		return memory.readbyte(address)
	elseif size == 2 then
		return memory.read_u16_le(address)
	elseif size == 4 then
		return memory.read_u32_le(address)
	end
end


-- Return the new value only when changing from 0
local function zeroChange(newValue, prevValue) 
	if (newValue == 0 or (newValue ~= 0 and prevValue == 0)) then
		return newValue
	else
		return prevValue
	end
end

local function clamp(newValue, prevValue, address, item)
	if item.min then
		newValue = math.max(newValue, item.min)
	end
	if item.max then
		newValue = math.min(newValue, item.max)
	end
	return newValue
end


ramItems = 
{
	--Swords
	[0xF345] = {name="Sword of Wind", type="bool"},
	[0xF346] = {name="Sword of Fire", type="bool"},
	[0xF347] = {name="Sword of Water", type="bool"},
	[0xF348] = {name="Sword of Thunder", type="bool"},

	--Armor
	[0xF349] = {name="Tanned Armor", type="bool"},
	[0xF34A] = {name="Leather Armor", type="bool"},
	[0xF34A] = {name="Bronze Armor", type="bool"},
	[0xF34B] = {name="Platinum Armor", type="bool"},
	[0xF349] = {name="Soldier Suit", type="bool"},
	[0xF34A] = {name="Ceramic Suit", type="bool"},
	[0xF34B] = {name="Battle Armor", type="bool"},
	[0xF34A] = {name="Psycho Armor", type="bool"},

		--Armor
	[0xF349] = {name="Carapace Shield", type="bool"},
	[0xF34A] = {name="Bronze Shield", type="bool"},
	[0xF34A] = {name="Platinum Shield", type="bool"},
	[0xF34B] = {name="Mirrored Shield", type="bool"},
	[0xF349] = {name="Ceramic Shield", type="bool"},
	[0xF34A] = {name="Sacred Shield", type="bool"},
	[0xF34B] = {name="Battle Shield", type="bool"},
	[0xF34A] = {name="Psycho Shield", type="bool"},


	--Shields
	[0xF349] = {name="Carapace Shield", type="bool"},
	[0xF349] = {name="Bronze Shield", type="bool"},
	[0xF349] = {name="Platinum Shield", type="bool"},
	[0xF349] = {name="Mirrored Shield", type="bool"},
	[0xF349] = {name="Sacred Shield", type="bool"},
	[0xF349] = {name="Battle Shield", type="bool"},
	[0xF349] = {name="Psycho Shield", type="bool"},

	--Power Upgrades
	[0xF349] = {name="Ball of Wind", type="bool"},
	[0xF34A] = {name="Ball of Fire", type="bool"},
	[0xF34B] = {name="Ball of Water", type="bool"},
	[0xF349] = {name="Ball of Thunder", type="bool"},
	[0xF34A] = {name="Tornado Bracelet", type="bool"},
	[0xF34B] = {name="Flame Bracelet", type="bool"},
	[0xF34A] = {name="Blizzard Bracelet", type="bool"},
	[0xF34B] = {name="Storm Bracelet", type="bool"},

	--Consumables (This is a variable one)
	[0xF349] = {name="Medical Herb", type="bool"},
	[0xF34A] = {name="Antidote", type="bool"},
	[0xF34B] = {name="Lysis Plant", type="bool"},
	[0xF349] = {name="Fruit of Power", type="bool"},
	[0xF34A] = {name="Fruit of Lime", type="bool"},
	[0xF34B] = {name="Fruit of Repun", type="bool"},
	[0xF349] = {name="Magic Ring", type="bool"},
	[0xF34A] = {name="Warp Boots", type="bool"},
	[0xF34B] = {name="Opel Statue", type="bool"},


	-- UI values
	[0xF360] = {flag="ammo", type="delta", size=2, receiveFunc=clamp, min=0, max=9999}, -- Current Rupees
	[0xF36A] = {flag="ammo", type="delta", receiveFunc=clamp, min=0, max=999}, -- Wishing Pond Rupees
	[0xF36C] = {type="delta", default=0x18, receiveFunc=clamp, min=0, max=0xF0}, -- HP Max
	
}



-- Display a message of the ram event
function getGUImessage(address, prevVal, newVal, user)
	-- Only display the message if there is a name for the address
	local name = ramItems[address].name
	if name and prevVal ~= newVal then
		-- If boolean, show 'Removed' for false
		if ramItems[address].type == "bool" then				
			gui.addmessage(user .. ": " .. name .. (newVal == 0 and 'Removed' or ''))
		-- If numeric, show the indexed name or name with value
		elseif ramItems[address].type == "num" then
			if (type(name) == 'string') then
				gui.addmessage(user .. ": " .. name .. " = " .. newVal)
			elseif (name[newVal]) then
				gui.addmessage(user .. ": " .. name[newVal])
			end
		-- If bitflag, show each bit: the indexed name or bit index as a boolean
		elseif ramItems[address].type == "bit" then
			for b=0,7 do
				local newBit = bit.check(newVal, b)
				local prevBit = bit.check(prevVal, b)

				if (newBit ~= prevBit) then
					if (type(name) == 'string') then
						gui.addmessage(user .. ": " .. name .. " flag " .. b .. (newBit and '' or ' Removed'))
					elseif (name[b]) then
						gui.addmessage(user .. ": " .. name[b] .. (newBit and '' or ' Removed'))
					end
				end
			end
		-- if delta, show the indexed name, or the differential
		elseif ramItems[address].type == "delta" then
			local delta = newVal - prevVal
			if (delta > 0) then
				if (type(name) == 'string') then
					gui.addmessage(user .. ": " .. name .. (delta > 0 and " +" or " ") .. delta)
				elseif (name[newVal]) then
					gui.addmessage(user .. ": " .. name[newVal])
				end
			end
		else 
			gui.addmessage("Unknown item ram type")
		end
	end
end



-- Get a list of changed ram events
function eventRAMchanges(prevRAM, newRAM)
	local ramevents = {}
	local changes = false

	for address, val in pairs(newRAM) do
		-- If change found
		if (prevRAM[address] ~= val) then
			getGUImessage(address, prevRAM[address], val, config.user)

			-- If boolean, get T/F
			if ramItems[address].type == "bool" then
				ramevents[address] = (val ~= 0)
				changes = true
			-- If numeric, get value
			elseif ramItems[address].type == "num" then
				ramevents[address] = val				
				changes = true
			-- If bitflag, get the changed bits
			elseif ramItems[address].type == "bit" then
				local changedBits = {}
				for b=0,7 do
					local newBit = bit.check(val, b)
					local prevBit = bit.check(prevRAM[address], b)

					if (newBit ~= prevBit) then
						changedBits[b] = newBit
					end
				end
				ramevents[address] = changedBits
				changes = true
			-- If delta, get the change from prevRAM frame
			elseif ramItems[address].type == "delta" then
				ramevents[address] = val - prevRAM[address]
				changes = true
			else 
				printOutput("Unknown item ram type")
			end
		end
	end

	if (changes) then
		return ramevents
	else
		return false
	end
end


-- set a list of ram events
function setRAMchanges(prevRAM, their_user, newEvents)
	for address, val in pairs(newEvents) do
		local newval

		-- If boolean type value
		if ramItems[address].type == "bool" then
			newval = (val and 1 or 0)
		-- If numeric type value
		elseif ramItems[address].type == "num" then
			newval = val
		-- If bitflag update each bit
		elseif ramItems[address].type == "bit" then
			newval = prevRAM[address]
			for b, bitval in pairs(val) do
				if bitval then
					newval = bit.set(newval, b)
				else
					newval = bit.clear(newval, b)
				end
			end
		-- If delta, add to the previous value
		elseif ramItems[address].type == "delta" then
			newval = prevRAM[address] + val
		else 
			printOutput("Unknown item ram type")
			newval = prevRAM[address]
		end

		-- Run the address's reveive function if it exists
		if (ramItems[address].receiveFunc) then
			newval = ramItems[address].receiveFunc(newval, prevRAM[address], address, ramItems[address], their_user)
		end

		-- Apply the address's bit mask
		if (ramItems[address].mask) then
			local xMask = bit.bxor(ramItems[address].mask, 0xFF)
			local prevval = readRAM("WRAM", address, ramItems[address].size)

			prevval = bit.band(prevval, xMask)
			newval = bit.band(newval, ramItems[address].mask)
			newval = bit.bor(prevval, newval)
		end

		-- Write the new value
		getGUImessage(address, prevRAM[address], newval, their_user)
		prevRAM[address] = newval
		if gameLoadedModes[gameMode] then
			writeRAM("WRAM", address, ramItems[address].size, newval)
		end
	end	
	return prevRAM
end

local splitItems = {}
function removeItems()
	-- Reload Core to restore previously removed items
	client.reboot_core()
	prevDomain = ""

	local junkItemsCount = tableCount(junkItems)
	math.randomseed(os.time())
	math.random(junkItemsCount)

	for ID, location in pairs(locations) do
		-- Remove item if it's not yours
		if (splitItems[ID] ~= my_ID) then
			local oldVal = readRAM("CARTROM", location.address, 1)
			if (location.type == "Key") then
				-- Move last enemy in list over the key item
				writeRAM("CARTROM", location.address, 2, readRAM("CARTROM", location.address2, 2))
				writeRAM("CARTROM", location.address + 2, 1, readRAM("CARTROM", location.address2 + 2, 1))
				writeRAM("CARTROM", location.address2, 1, 0xFF)
			elseif (location.type == "Pot") then
				writeRAM("CARTROM", location.address, 1, 0x01) -- Remove pot key
			elseif (location.type == "Shop") then
				for _,shopitem in pairs(location.items) do
					writeRAM("CARTROM", shopitem.address, 1, shopitem.newval)
				end
			elseif (items[oldVal]) and
				(config.ramconfig.bkey or not bigKeys[oldVal]) and 
				(config.ramconfig.skey or not smallKeys[oldVal]) then
				-- Remove Item
				if config.ramconfig.junk then
					-- Fill with junk
					writeRAM("CARTROM", location.address, 1, junkItems[math.random(junkItemsCount)].val)
				else
					-- Empty chest
					writeRAM("CARTROM", location.address, 1, 0x5A)
				end
			end
		end
	end
end

client.reboot_core()
prevDomain = ""


-- If not rupee arrows, add arrows from junk pool
if readRAM("CARTROM", 0x180175, 1) == 0 then
	table.insert(junkItems, {['val']=0x43, ['name']='Arrow'})
	table.insert(junkItems, {['val']=0x44, ['name']='Ten Arrows'})
end


-- Get Shop item locations
local shopItems = {}
local nextItemAddress = 0x184900
local nextItem = readRAM("CARTROM", nextItemAddress + 1, 1)
while nextItem ~= 0xFF do
	if (nextItem == 0x30) or (nextItem == 0x3E) or (nextItem == 0x5E) then
		local shopID = readRAM("CARTROM", nextItemAddress, 1)

		local newVal
		if (nextItem == 0x30) then
			newVal = 0x41 -- 50 Rupees
		elseif (nextItem == 0x3E) then
			newVal = 0x31 -- 10 Bombs
		elseif (nextItem == 0x5E) then
			newVal = 0x40 -- 100 Rupees
		end

		if (shopItems[shopID] == nil) then
			shopItems[shopID] = {
				["items"] = {
					{["address"] = nextItemAddress + 1,
					["newval"] = newVal}},
				["type"] = "Shop",
				["address"] = nextItemAddress
			}
		else 
			table.insert(shopItems[shopID].items, {
				["address"] = nextItemAddress + 1,
				["newval"] = newVal
			})
		end
	end

	nextItemAddress = nextItemAddress + 8
	nextItem = readRAM("CARTROM", nextItemAddress + 1, 1)
end
for _,shop in pairs(shopItems) do
	table.insert(locations, shop)
end



-- Get chest locations
for ID = 0,167 do
	table.insert(locations, {
		["address"] = 0xE96E + (ID * 3),
		["type"] = "Chest"
	})
end


-- Get enemy key drops (load dynamically for pot shuffling)
for ID = 0,0x17F do
	local roomspritesptr = 0x040000 + readRAM("CARTROM", 0x04D62E + (ID * 2), 2)
	roomspritesptr = roomspritesptr + 1 -- ignore first byte of list

	local keyfound = false
	while (readRAM("CARTROM", roomspritesptr, 1) ~= 0xFF) do
		if readRAM("CARTROM", roomspritesptr + 2, 1) == 0xE4 then
			keyfound = roomspritesptr
		end
		roomspritesptr = roomspritesptr + 3
	end
	if keyfound then
		table.insert(locations, {
			["address"] = keyfound,
			["address2"] = roomspritesptr - 3,
			["type"] = "Key"
		})
	end
end

-- Get pot key locations
for ID = 0,0x13F do
	local roomsecretssptr = 0x000000 + readRAM("CARTROM", 0x00DB67 + (ID * 2), 2)
	while (readRAM("CARTROM", roomsecretssptr, 2) ~= 0xFFFF) do
		if readRAM("CARTROM", roomsecretssptr + 2, 1) == 0x08 then
			table.insert(locations, {
				["address"] = roomsecretssptr + 2,
				["type"] = "Pot"
			})
		end
		roomsecretssptr = roomsecretssptr + 3
	end
end
lttp_ram.itemcount = 0
for _,_ in pairs(locations) do lttp_ram.itemcount = lttp_ram.itemcount + 1 end

local messageQueue = {first = 0, last = -1}
function messageQueue.isEmpty()
	return messageQueue.first > messageQueue.last
end
function messageQueue.pushLeft (value)
  local first = messageQueue.first - 1
  messageQueue.first = first
  messageQueue[first] = value
end
function messageQueue.pushRight (value)
  local last = messageQueue.last + 1
  messageQueue.last = last
  messageQueue[last] = value
end
function messageQueue.popLeft ()
  local first = messageQueue.first
  if messageQueue.isEmpty() then error("list is empty") end
  local value = messageQueue[first]
  messageQueue[first] = nil        -- to allow garbage collection
  messageQueue.first = first + 1
  return value
end
function messageQueue.popRight ()
  local last = messageQueue.last
  if messageQueue.isEmpty() then error("list is empty") end
  local value = messageQueue[last]
  messageQueue[last] = nil         -- to allow garbage collection
  messageQueue.last = last - 1
  return value
end


-- Gets a message to send to the other player of new changes
-- Returns the message as a dictionary object
-- Returns false if no message is to be send
function lttp_ram.getMessage()
	-- Check if game is playing
	gameMode = readRAM("WRAM", 0x0010, 1)
	local gameLoaded = gameLoadedModes[gameMode] == true

	-- Don't check for updated when game is not running
	if not gameLoaded then
		prevGameMode = gameMode
		return false
	end

	-- Update dungeon key counts
	updateKey()

	-- Initilize previous RAM frame if missing
	if prevRAM == nil then
		prevRAM = getRAM()
	end

	-- Checked for queued death and apply when safe
	if config.ramconfig.ammo and tableCount(deathQueue) > 0 and not deathQueue[config.user] then
		-- Main mode: 07 = Dungeon, 09 = Overworld, 0B = Special Overworld
		-- Sub mode: Non 0 = game is paused, transitioning between modes
		if (gameMode == 0x07 or gameMode == 0x09 or gameMode == 0x0B) and (readRAM("WRAM", 0x0011, 1) == 0x00) then 
			-- If link is controllable
			writeRAM("WRAM", 0x0010, 2, 0x0012) -- Kill link as soon as it's safe
			writeRAM("WRAM", 0xF36D, 1, 0)
			writeRAM("WRAM", 0x04C6, 1, 0) -- Stop any special cutscenes
			prevRAM[0xF36D] = 0
			gameMode = 0x12
		end
	end

	if config.ramconfig.ammo and gameMode == 0x12 then
		local deathCount = tableCount(deathQueue)
		if (deathCount > 0 and deathCount < playercount) then
			-- Lock the death until everyone is dying
			writeRAM("WRAM", 0x0010, 2, 0x0012)
		elseif (deathCount >= playercount) then
			deathQueue = {}

			local hasFairy = false
			for bottleID=0,3 do
				if prevRAM[0xF35C + bottleID] == 0x06 then
					-- has fairy
					hasFairy = true
				end
			end

			local maxHP = readRAM("WRAM", 0xF36C, 1)
			local contHP
			if (hasFairy) then
				contHP = 7 * 8
			else
			 	contHP = (continueHP[maxHP / 8] or 10) * 8
			end
			prevRAM[0xF36D] = math.max(math.min(prevRAM[0xF36D] + contHP, maxHP), 0)
			writeRAM("WRAM", 0xF36D, 1, prevRAM[0xF36D])		
		end

		if (prevGameMode == 0x12) then
			-- discard continue HP/fairy HP
			writeRAM("WRAM", 0xF36D, 1, prevRAM[0xF36D])
		end
	end

	-- Game was just loaded, restore to previous known RAM state
	if (gameLoaded and not gameLoadedModes[prevGameMode]) then
		 -- get changes to prevRAM and apply them to game RAM
		local newRAM = getRAM()
		local message = eventRAMchanges(newRAM, prevRAM)
		prevRAM = newRAM
		if (message) then
			lttp_ram.processMessage("Save Restore", message)
		end
	end

	-- Load all queued changes
	while not messageQueue.isEmpty() do
		local nextmessage = messageQueue.popLeft()
		lttp_ram.processMessage(nextmessage.their_user, nextmessage.message)
	end

	-- Get current RAM events
	local newRAM = getRAM()
	local message = eventRAMchanges(prevRAM, newRAM)

	-- Update the RAM frame pointer
	prevRAM = newRAM

	-- Get boss damages
	if config.ramconfig.boss then
		local damages = getBossDamage()
		if damages then
			setBossDamage(damages, config.user, true)
			if message == false then
				message = {}
			end
			message["b"] = damages
		end
	end

	-- Check for death message
	if config.ramconfig.ammo and gameMode == 0x12 then
		if (prevGameMode ~= 0x12) then
			if message == false then
				message = {}
			end

			message[0xF36D] = -0x100 -- death message is a large HP loss
			deathQueue[config.user] = true
		else 
			-- suppress all non death messages during death sequence
			return false
		end
	end
	prevGameMode = gameMode

	return message
end


-- Process a message from another player and update RAM
function lttp_ram.processMessage(their_user, message)
	if message["i"] then
		splitItems = message["i"]
		message["i"] = nil
		removeItems()

		local playerlist = {}
		playercount = 0
		for _,player in pairs(splitItems) do
			if playerlist[player] == nil then
				playerlist[player] = true
				playercount = playercount + 1
			end
		end
	end

	if message["b"] then
		setBossDamage(message["b"], their_user, false)
		message["b"] = nil
	end

	if gameLoadedModes[gameMode] then
		prevRAM = setRAMchanges(prevRAM, their_user, message)
	else
		messageQueue.pushRight({["their_user"]=their_user, ["message"]=message})
	end
end

local configformState

function configOK() 
	configformState = "OK"
end
function configCancel() 
	configformState = "Cancel"
end


function lttp_ram.getConfig()
	configformState = "Idle"

	forms.setproperty(mainform, "Enabled", false)

	local configform = forms.newform(130, 195, "")
	local chkAmmo = forms.checkbox(configform, "Health and Ammo", 10, 10)
	forms.setproperty(chkAmmo, 'Width', 200)
	local chkBKey = forms.checkbox(configform, "Split Big Keys", 10, 30)
	local chkSKey = forms.checkbox(configform, "Split Small Keys", 10, 50)
	local chkBoss = forms.checkbox(configform, "Raid Bosses", 10, 70)
	local chkJunk = forms.checkbox(configform, "Junk Chests", 10, 90)
	local btnOK = forms.button(configform, "OK", configOK, 10, 120, 50, 23)
	local btnCancel = forms.button(configform, "Cancel", configCancel, 70, 120, 50, 23)

	while configformState == "Idle" do
		coroutine.yield()
	end

	local config = {
		['ammo'] = forms.ischecked(chkAmmo),
		['bkey'] = forms.ischecked(chkBKey),
		['skey'] = forms.ischecked(chkSKey),
		['boss'] = forms.ischecked(chkBoss),
		['junk'] = forms.ischecked(chkJunk)
	}

	forms.destroy(configform)
	forms.setproperty(mainform, "Enabled", true)

	if configformState == "OK" then
		return config
	else
		return false
	end
end

return lttp_ram


